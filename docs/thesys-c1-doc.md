# Thesys C1 - Comprehensive Documentation

**Author:** Manus AI  
**Date:** October 8, 2025  
**Source:** [Thesys Documentation](https://docs.thesys.dev)

## Table of Contents

1. [Introduction](#introduction)
2. [What is C1 by Thesys?](#what-is-c1-by-thesys)
3. [How C1 Works](#how-c1-works)
4. [Getting Started](#getting-started)
5. [Core Concepts](#core-concepts)
6. [Backend Integration](#backend-integration)
7. [Frontend Implementation](#frontend-implementation)
8. [Interactivity System](#interactivity-system)
9. [Advanced Features](#advanced-features)
10. [API Reference](#api-reference)
11. [Best Practices](#best-practices)

---

## Introduction

Thesys C1 represents a paradigm shift in AI application development through **Generative UI** - where artificial intelligence dynamically generates user interfaces rather than just text responses. This comprehensive documentation covers all aspects of C1, from basic concepts to advanced implementation patterns, providing developers with the knowledge needed to build sophisticated AI-native applications.

## What is C1 by Thesys?

### Overview

C1 is the **Generative UI API for AI-native applications** that transforms natural language prompts into live, interactive user interface components. Unlike traditional approaches that require manual conversion of LLM outputs into UI elements, C1 generates complete interface specifications that can be rendered directly in web applications.

### Key Features

**Interactive Components**
The generated UI supports a comprehensive range of interactive elements including charts with tooltips, clickable buttons that continue conversations, and forms that capture user input for subsequent actions. These components are not static displays but fully functional interface elements.

**Themeable Design System**
C1 seamlessly adapts to existing brand guidelines and design systems. The generated UI includes built-in support for dark mode and can be customized to match any visual identity through comprehensive theming capabilities.

**Real-time UI Streaming**
Unlike traditional approaches that wait for complete responses, C1 streams UI components as they are generated. This progressive rendering creates a more responsive user experience, with interface elements appearing on screen immediately as they become available.

**OpenAI-Compatible API**
The API maintains full compatibility with OpenAI's Chat Completions format, enabling seamless integration with existing codebases. Developers can adopt C1 with minimal changes to their current OpenAI implementations.

**Robust Error Handling**
C1 includes sophisticated error recovery mechanisms. When LLM providers experience downtime, C1 automatically retries requests or routes to fallback providers. Additionally, the system detects and corrects incomplete or invalid responses in real-time.

### Use Cases

**Analytics Dashboards**
Transform queries like "Show me monthly revenue trends" into interactive line charts with drill-down capabilities and real-time data visualization.

**Conversational Agents**
Convert complex requests such as "Book me a flight and confirm details" into multi-step forms within chat interfaces, streamlining user interactions.

**Internal Tools**
Generate comprehensive interfaces for queries like "List all users who signed up in the last 30 days" with interactive tables and accompanying analytics visualizations.

**E-commerce Flows**
Create complete checkout experiences from simple requests like "Add this product to my cart and checkout" with dynamic pricing and payment processing interfaces.

**AI Agent Enhancement**
Reimagine existing AI agents (customer support bots, copilots, research assistants) with generative UI layers that replace text-only interactions with forms, dashboards, and interactive workflows.

## How C1 Works

### Architecture Overview

The C1 system operates through a structured flow that involves three main components: the user interface, your backend server, and the C1 API. This architecture ensures security, flexibility, and optimal performance.

**Process Flow:**

1. **User Input**: Users enter prompts through your application's interface
2. **Backend Processing**: Your server receives the prompt and enriches it with context, history, and system instructions
3. **C1 API Call**: Your backend calls the C1 API using OpenAI-compatible endpoints
4. **UI Specification Generation**: C1 returns a structured UI specification (C1 DSL) generated by advanced language models
5. **Response Relay**: Your backend forwards the C1 response to the frontend
6. **UI Rendering**: The C1 React SDK renders the specification as interactive components

### The Backend Integration Pattern

Your backend serves as an intelligent intermediary, enabling you to add business logic, prepare contextual data, and secure API credentials. The C1 API's OpenAI compatibility means existing OpenAI integrations require only configuration changes.

### Model Selection

C1 supports multiple state-of-the-art language models:

- **Anthropic Claude Sonnet 4**: Optimized for complex reasoning and detailed UI generation
- **OpenAI GPT-5**: Advanced capabilities for nuanced interface creation

Model selection depends on specific use case requirements, with each offering distinct advantages for different application types.

## Getting Started

### Quick Setup

**NextJS Implementation**

The fastest path to C1 integration uses the official CLI tool:

```bash
npx create-c1-app
cd my-c1-project
npm run dev
```

This creates a complete starter project with backend API routes, frontend components, and example implementations.

**Python/FastAPI Implementation**

For Python-based backends:

```bash
git clone https://github.com/thesysdev/template-c1-fastapi.git my-c1-project
cd my-c1-project/backend
pip install -r requirements.txt
uvicorn main:app --reload
```

### System Requirements

- **Node.js**: Version 20.9 or later
- **Python**: Version 3.x (for Python backends)
- **Operating Systems**: macOS, Windows, or Linux
- **Browser**: Modern browsers with ES6+ support

### Component Selection

C1 provides two primary components for different use cases:

**`<C1Component>`**: Core renderer for custom implementations requiring full control over data fetching and state management.

**`<C1Chat>`**: Complete chat interface with built-in conversation history, message composition, and loading states.

## Core Concepts

### Generative UI Paradigm

Traditional AI applications generate text that developers must manually convert into user interfaces. Generative UI represents a fundamental shift where AI directly creates interface specifications, eliminating the manual conversion step and enabling more sophisticated, dynamic user experiences.

### C1 DSL (Domain Specific Language)

The C1 DSL is a structured specification format that describes user interfaces in a way that can be rendered by the React SDK. This specification includes component definitions, styling information, interaction handlers, and state management instructions.

### System Prompts and UI Guidance

System prompts serve as instructions that guide the model's UI generation behavior. These prompts ensure consistent outputs while providing developers with fine-grained control over the generated interfaces.

**Example System Prompt:**

```typescript
export const systemPrompt = `
You are a business research assistant. Your goal is to provide concise and
accurate information about companies. When responding, follow these rules:

Rules:
- Use tables to show structured data such as financial highlights, key executives, or product lists.
- Use graphs to visualize quantitative information like stock performance or revenue growth.
- Use carousels to show information about products from the company.
`;
```

## Backend Integration

### Authentication and Setup

C1 API authentication uses standard Bearer token format with your Thesys API key. The setup process involves configuring the OpenAI client with C1-specific endpoints:

```python
import os
from openai import OpenAI

# Initialize the client with your C1 API Key and the C1 Base URL
client = OpenAI(
    api_key=os.environ.get("THESYS_API_KEY"),
    base_url="https://api.thesys.dev/v1/embed"
)
```

### Message Structure

The core of every C1 request is the messages array, which provides conversational context to the model:

- **`system`**: High-level instructions or context for the AI
- **`user`**: Prompts or messages from end-users  
- **`assistant`**: Previous responses from the AI

**Conversation History Management:**

```json
[
    { "role": "system", "content": "You are a helpful assistant that generates UI." },
    { "role": "user", "content": "Show me last month's sales." },
    { "role": "assistant", "content": "<UI spec for a sales chart...>" },
    { "role": "user", "content": "Now break it down by region." }
]
```

### Implementation Patterns

**Conversational Applications**

For applications requiring conversation history:

```python
import os
from openai import OpenAI
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()
client = OpenAI(
    api_key=os.environ.get("THESYS_API_KEY"),
    base_url="https://api.thesys.dev/v1/embed"
)

# In-memory store for conversation history
conversation_history = [
    {"role": "system", "content": "You are a helpful assistant."}
]

class ChatRequest(BaseModel):
    prompt: str

@app.post("/chat")
def chat(request: ChatRequest):
    # Add the new user message to the history
    conversation_history.append({"role": "user", "content": request.prompt})

    # Call the C1 API with the full history
    completion = client.chat.completions.create(
        model="c1-model-name",
        messages=conversation_history,
    )
    assistant_response = completion.choices[0].message

    # Add the AI's response to the history
    conversation_history.append(assistant_response)

    # Return the latest response content to the frontend
    return assistant_response.content
```

### Tool Integration

C1 supports comprehensive tool integration for connecting to live data sources:

```typescript
import { JSONSchema } from "openai/lib/jsonschema.mjs";
import { RunnableToolFunctionWithParse } from "openai/lib/RunnableFunction.mjs";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { tavily } from "@tavily/core";

const tavilyClient = tavily({ apiKey: process.env.TAVILY_API_KEY });

export const tools: [
  RunnableToolFunctionWithParse<{
    searchQuery: string;
  }>
] = [
  {
    type: "function",
    function: {
      name: "web_search",
      description: "Search the web for a given query, will return details about anything including business",
      parse: (input) => {
        return JSON.parse(input) as { searchQuery: string };
      },
      parameters: zodToJsonSchema(
        z.object({
          searchQuery: z.string().describe("search query"),
        })
      ) as JSONSchema,
      function: async ({ searchQuery }: { searchQuery: string }) => {
        const results = await tavilyClient.search(searchQuery, {
          maxResults: 5,
        });
        return JSON.stringify(results);
      },
      strict: true,
    },
  },
];
```

## Frontend Implementation

### SDK Installation and Setup

The C1 React SDK requires two packages for complete functionality:

```bash
npm install @thesysai/genui-sdk @crayonai/react-ui
```

**Required CSS Import:**

```javascript
import "@crayonai/react-ui/styles/index.css";
```

**Default Font Configuration:**

```css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
```

### Core Renderer Implementation

The `<C1Component>` serves as the fundamental building block for rendering C1 API responses:

```javascript
import { C1Component, ThemeProvider } from "@thesysai/genui-sdk";
import "@crayonai/react-ui/styles/index.css";

const App = () => {
  const response = await fetch("/chat");
  return (
    <ThemeProvider>
      <C1Component c1Response={response.text()} />
    </ThemeProvider>
  );
};
```

### Theme Provider Integration

The `<ThemeProvider>` ensures proper styling and provides access to design tokens:

```javascript
import { C1Component, ThemeProvider } from "@thesysai/genui-sdk";

const App = () => {
  const response = await fetch("/chat");
  return (
    <ThemeProvider>
      <C1Component c1Response={response.text()} />
    </ThemeProvider>
  );
};
```

### Conversational Interface Implementation

For chat applications, `<C1Chat>` provides a complete solution:

```javascript
import { C1Chat } from "@thesysai/genui-sdk";
import "@crayonai/react-ui/styles/index.css";

const App = () => {
  return <C1Chat apiUrl="/api/chat" />;
};
```

### Streaming Implementation

Real-time streaming requires manual stream handling for optimal user experience:

```javascript
import { useState } from "react";
import { C1Component, ThemeProvider } from "@thesysai/genui-sdk";

function MyStreamingComponent() {
  const [c1Response, setC1Response] = useState<string>("");
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const handleGenerate = async (prompt: string) => {
    setIsLoading(true);
    setC1Response("");

    try {
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt }),
      });

      if (!response.body) {
        throw new Error("Response body is empty.");
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let accumulatedResponse = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        accumulatedResponse += chunk;
        setC1Response(accumulatedResponse);
      }
    } catch (error) {
      console.error("Error fetching or reading stream:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <ThemeProvider>
      <button onClick={() => handleGenerate("Show me sales data")}>
        Generate Report
      </button>
      <C1Component
        c1Response={c1Response}
        isStreaming={isLoading}
      />
    </ThemeProvider>
  );
}
```

## Interactivity System

### State Management

C1 components maintain state automatically, remembering user input across interactions and page reloads. This stateful behavior enables sophisticated form handling and persistent user experiences.

**Automatic State Management**

Built-in C1 components (forms, inputs, toggles) handle state automatically without requiring custom `useState` or `onChange` handlers.

**State Persistence**

The `updateMessage` callback enables state persistence across sessions:

```javascript
<C1Component
  c1Response={initialC1Response}
  updateMessage={(updatedC1Response) => {
    // Save the complete C1 DSL with merged state to database
    saveToDatabase({
      content: updatedC1Response,
    });
  }}
/>
```

**Custom Component State Integration**

Custom components can integrate with C1's state system using the `useC1State` hook:

```javascript
import { useC1State } from '@thesysai/genui-sdk';

function CustomToggle() {
  const [value, setValue] = useC1State('toggle-enabled');

  return (
    <button onClick={() => setValue(!value)}>
      {value ? 'On' : 'Off'}
    </button>
  );
}
```

### Actions and Event Handling

Actions represent user interactions that trigger application responses. The action system supports both client-side effects and generative updates.

**Action Implementation**

```javascript
import { useState } from "react";
import { C1Component, ThemeProvider } from "@thesysai/genui-sdk";

function MyInteractiveComponent() {
  const [c1Response, setC1Response] = useState<string>(/* initial C1 DSL */);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const handleAction = async (action) => {
    callApi({ 
      prompt: action.llmFriendlyMessage, 
      userVisibleMessage: action.userFriendlyMessage 
    });
  };

  return (
    <ThemeProvider>
      <C1Component
        c1Response={c1Response}
        isStreaming={isLoading}
        onAction={handleAction}
      />
    </ThemeProvider>
  );
}
```

**Action Object Structure**

```javascript
{
  "userFriendlyMessage": "Plan my trip",
  "llmFriendlyMessage": "The user submitted the trip planning form. form values: { ...values }"
}
```

### Forms and Input Handling

C1 supports comprehensive form generation and management with automatic state tracking and submission handling.

**Supported Input Types:**
- Text and Number inputs
- Date inputs and Textareas  
- Dropdowns, Checkboxes, and Radio buttons
- Sliders and Switches

**Automatic Form Generation from Tool Schema**

```typescript
const tools = [
  {
    type: "function",
    function: {
      name: "create_jira_issue",
      description: "Create a Jira issue",
      parameters: {
        type: "object",
        properties: {
          title: {
            type: "string",
            description: "The title of the Jira issue"
          },
          priority: {
            type: "string",
            enum: ["Low", "Medium", "High"],
            description: "The priority of the Jira issue"
          },
          description: {
            type: "string",
            description: "A multiline description for the issue"
          }
        },
        required: ["title", "priority", "description"]
      }
    }
  }
];
```

**Form Submission Handling**

```javascript
const handleFormSubmit = async (action) => {
  console.log("Form submitted with payload:", action.payload);
  console.log("Message to be shown to user:", action.userFriendlyMessage);
  console.log("Message for LLM:", action.llmFriendlyMessage);

  const response = await fetch("/api/chat", {
    method: "POST",
    body: JSON.stringify({ prompt: action.llmFriendlyMessage }),
  });

  const c1Response = await response.text();
  setC1Response(c1Response);
};
```

### Multi-Step Flows

Multi-step flows enable complex, workflow-driven user experiences through chained actions that generate progressive UI updates.

**Generative Loop Pattern**

The core pattern involves: User Action → New Prompt → New UI → User Action, creating dynamic, evolving interfaces that respond to user input with contextually appropriate next steps.

## Advanced Features

### Custom Components

C1 supports custom component integration for domain-specific requirements not covered by built-in components. Custom components can integrate fully with C1's state management and action systems.

### Error Handling and Recovery

C1 includes comprehensive error handling mechanisms:

- **Provider Failover**: Automatic routing to backup LLM providers during outages
- **Response Validation**: Real-time detection and correction of invalid responses
- **Graceful Degradation**: Fallback behaviors for network or API issues

### Custom Markdown Responses

For scenarios requiring custom responses (such as guardrails or interceptors), C1 supports custom markdown rendering:

```javascript
import { makeC1Response } from "@thesysai/genui-sdk/server";

export async function POST(req: NextRequest) {
  const c1Response = makeC1Response();
  
  if (checkForPII(prompt)) {
    c1Response.writeCustomMarkdown(
      "I'm unable to assist with this request because it contains, or asks for, PII (*personally identifiable information*). Please remove any sensitive information and try again."
    );
    c1Response.end();
    return new NextResponse(c1Response.responseStream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        Connection: "keep-alive",
      },
    });
  }
  // Continue with normal processing...
}
```

### Theming and Customization

C1 provides extensive theming capabilities to match existing design systems:

- **CSS Variable Override**: Customize colors, typography, and spacing
- **Component-Level Styling**: Override specific component appearances
- **Dark Mode Support**: Built-in dark mode with automatic switching
- **Brand Integration**: Seamless integration with existing design tokens

## API Reference

### Supported Parameters

The C1 API supports standard OpenAI chat completion parameters:

- **`model`** (string, required): The model ID for generation
- **`messages`** (array, required): Conversation history objects
- **`stream`** (boolean, optional): Enable streaming responses
- **`temperature`** (number, optional): Controls randomness (default: 1.0)
- **`max_tokens`** (integer, optional): Maximum tokens to generate
- **`top_p`** (number, optional): Nucleus sampling parameter
- **`stop`** (string/array, optional): Stop sequences for generation

### Error Response Format

```json
{
  "error": {
    "message": "Invalid API key provided.",
    "type": "invalid_request_error",
    "param": null,
    "code": "invalid_api_key"
  }
}
```

### Streaming Configuration

**Backend Streaming Setup (Python/FastAPI):**

```python
from thesys_genui_sdk.fast_api import with_c1_response
from thesys_genui_sdk.context import write_content, get_assistant_message

@app.post("/chat")
@with_c1_response()
async def chat(request: ChatRequest):
    stream = client.chat.completions.create(
        model="c1-model-name",
        messages=[{"role": "user", "content": request.prompt}],
        stream=True,
    )

    for chunk in stream:
        content = chunk.choices.delta.content
        if content:
            await write_content(content)

    assistantMessage = get_assistant_message()
```

## Best Practices

### System Prompt Guidelines

- **Keep prompts concise**: Prefer clear, specific rules over lengthy descriptions
- **Avoid conflicts**: Ensure rules don't contradict each other
- **Domain-specific focus**: Tailor prompts to your specific use case
- **Iterative refinement**: Test with representative queries and refine based on results

### Performance Optimization

- **Implement streaming**: Use streaming for improved perceived performance
- **Optimize message history**: Manage conversation history size for optimal response times
- **Cache responses**: Implement appropriate caching strategies for repeated queries
- **Error boundaries**: Implement React error boundaries for graceful failure handling

### Security Considerations

- **API key protection**: Never expose API keys in client-side code
- **Input validation**: Validate user inputs before sending to C1 API
- **Content filtering**: Implement appropriate content filtering for your use case
- **Rate limiting**: Implement rate limiting to prevent abuse

### Development Workflow

- **Start with templates**: Use official templates for faster development
- **Incremental complexity**: Begin with simple implementations and add complexity gradually
- **Test thoroughly**: Test with diverse inputs and edge cases
- **Monitor usage**: Implement logging and monitoring for production deployments

---

## Conclusion

Thesys C1 represents a significant advancement in AI application development, enabling developers to create sophisticated, interactive user experiences through generative UI technology. By following the patterns and practices outlined in this documentation, developers can build applications that leverage the full power of AI-generated interfaces while maintaining control over user experience and business logic.

The combination of C1's powerful API, comprehensive React SDK, and flexible architecture provides a foundation for building the next generation of AI-native applications that go far beyond traditional text-based interactions.

---

**References:**

[1] Thesys Documentation - https://docs.thesys.dev  
[2] C1 API Reference - https://docs.thesys.dev/reference/c1-api  
[3] React SDK Documentation - https://docs.thesys.dev/reference/react-sdk  
[4] OpenAI API Compatibility - https://docs.thesys.dev/guides/implementing-api  
[5] Tool Calling Guide - https://docs.thesys.dev/guides/integrate-data/tool-calling
